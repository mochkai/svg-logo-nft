import { util } from "chai";
import { mkdirSync, readFileSync, rmdirSync, writeFileSync } from "fs";
import * as IPFS from "ipfs-http-client";
import random from "random";

class AutoGen {
  // Required Parameters
  private quantity: number;
  private ipfs: any;

  // Optional Parameters
  private propertiesConfig: any = this.getConfigJson("scripts/gen/config.json");
  private name: string = "SVG Logo";
  private description: string = "This logo has been autogenerated by Mochkai's script. If you would like to see it live chack it out on twitch!! https://www.twitch.tv/mochkai";
  private baseSVG: string = this.setBaseSVG('assets/baseSVG.svg');
  private outPath: string = 'assets/gen';
  private ipfsGateway: string = 'http://localhost:8080/ipfs/';
  private baseFolder: string = '/mochkai-logo/';
  private fileNamePrefix: string = 'logo_';
  private debug: boolean = true;

  // Autogenerated Parameters
  private attributes: any = null;
  private metadata: any = null;
  private jsonArray: Array<string> = [];

  constructor(_quantity: number, _configs?: any) {
    if (!_quantity && _quantity > 0) throw 'Quantity is required';

    this.quantity = _quantity;

    if (_configs)
      this.setConfigurations(_configs);

    if (!this.debug) process.stdout.write("Initialiing...");

    if (!this.propertiesConfig) throw 'No config file Found';

    rmdirSync(this.outPath, { recursive: true });

    if (!this.debug) process.stdout.write("Success!\n");
  }

  public generateMetadataAttributes() {
    let attributes = [];

    if (!this.debug) process.stdout.write("Generating Attributes... 0%");

    for (let item = 0; item < this.quantity; item++) {

      let _attributes = [];
      for (let property in this.propertiesConfig) {
        let curWeight = 0;
        let randomValue = random.float() * 100;
        let config = this.propertiesConfig[property];
        let configItem = config.find((p: any) => {
          curWeight += p.weight;

          if (curWeight - randomValue >= 0)
            return p;
        });

        _attributes.push({
          trait_type: property,
          value: configItem.value
        });
      }

      let tempAttr = JSON.stringify(_attributes);

      //Check for duplicate and restart process if found
      if (attributes.indexOf(tempAttr) == -1) {
        attributes[item] = tempAttr;
        if (!this.debug) {
          process.stdout.write("\r\x1b[K");
          process.stdout.write("Generating Attributes... " + ((attributes.length / this.quantity) * 100).toFixed(2) + "%");
        }
      } else {
        item--;
        this.debugLog("Duplicate Item found at ", attributes.indexOf(attributes[item]));
      }
    }

    if (!this.debug) process.stdout.write("\n");

    this.attributes = attributes;
  }

  public async generateMetadata() {
    let metadata: any = [];

    if (!this.debug) process.stdout.write("Generating Metadata with SVGs... 0%");

    for (let item = 0; item < this.quantity; item++) {
      metadata[item] = {
        name: this.name + " #" + (item + 1),
        description: this.description,
        attributes: JSON.parse(this.attributes ? this.attributes[item] : false)
      };

      if (metadata[item].attributes)
        metadata[item].image = await this.generateSVG(metadata[item].attributes, (item + 1));

      if (!this.debug) {
        process.stdout.write("\r\x1b[K");
        process.stdout.write("Generating Metadata with SVGs... " + ((metadata.length / this.quantity) * 100).toFixed(2) + "%");
      }
    }

    await this.ipfs.files.stat(this.baseFolder + "/image", { hash: true })
      .then((result: any) => {
        metadata.map((item: any) => {
          item.image = this.ipfsGateway + result.cid.toString() + item.image;
          return item;
        })
      })
      .catch((error: any) => this.debugLog("Stat file error: ", error));

    this.metadata = metadata;

    if (!this.debug) process.stdout.write("\n");

    this.debugLog(util.inspect(this.metadata, false, 10));
  }

  private async generateSVG(_attributes: any, index: number): Promise<string> {
    const fileName = "/" + this.fileNamePrefix + index.toString().padStart(this.quantity.toString().length, "0") + ".svg";

    let genSVG = this.baseSVG;

    for (let attr in _attributes) {
      this.debugLog(attr, _attributes[attr]);
      let property = this.camelCase(_attributes[attr].trait_type);

      this.debugLog(property);

      genSVG = genSVG.replace("{{" + property + "}}", _attributes[attr].value);

    }

    this.debugLog(genSVG);

    const fullPath = this.outPath + this.baseFolder + "image";

    try {
      mkdirSync(fullPath, { recursive: true });
      writeFileSync(fullPath + fileName, genSVG);
      this.debugLog("File generated successfully : ", fullPath + fileName);
    } catch (error) {
      this.debugLog("Error saving file to disk : ", fullPath + fileName);
      this.debugLog(error);
      throw 'Error Generating the SVG';
    }

    return new Promise((resolve, reject) => {
      this.ipfs.add({ path: fileName, content: genSVG }, { pin: true })
        .then((result: any) => {
          this.debugLog("File added to IPFS: ", result);

          this.debugLog("About to copy file to: ", this.baseFolder + "image" + fileName);

          this.ipfs.files.cp(result.cid, this.baseFolder + "image" + fileName, { parents: true, flush: true })
            .then((res: any) => {
              resolve(fileName);
            })
            .catch((error: any) => {
              this.debugLog(error);
              reject("Error: Could not copy files to requested path.");
            });
        })
        .catch((error: any) => {
          this.debugLog(error);
          reject("Error: Could not add files.");
        });
    })
  }

  public async generateJsonFiles(): Promise<string> {
    this.debugLog("About to generate JSON Files...");

    const fullPath = this.outPath + this.baseFolder + "json";

    for (let item in this.metadata) {
      const fileNumber = Number(item) + 1;
      console.log("fileNumber: ", fileNumber);
      const fileName = "/" + this.fileNamePrefix + fileNumber.toString().padStart(this.quantity.toString().length, "0") + ".json";
      const jsonMetadata = JSON.stringify(this.metadata[item]);

      try {
        mkdirSync(fullPath, { recursive: true });
        writeFileSync(fullPath + fileName, jsonMetadata);
        this.debugLog("File generated successfully : ", fullPath + fileName);
      } catch (error) {
        this.debugLog("Error saving file to disk : ", fullPath + fileName);
        this.debugLog(error);
        throw 'Error Generating the SVG';
      }

      await this.ipfs.add({ path: fileName, content: jsonMetadata }, { pin: true })
        .then((result: any) => {
          this.debugLog("File added to IPFS: ", result);

          this.debugLog("About to copy file to: ", this.baseFolder + "json" + fileName);

          this.ipfs.files.cp(result.cid, this.baseFolder + "json" + fileName, { parents: true, flush: true })
            .then(() => {
              this.jsonArray.push("/json" + fileName);
            })
            .catch((error: any) => {
              this.debugLog(error);
            });
        })
        .catch((error: any) => {
          this.debugLog(error);
        });
    }

    return new Promise((resolve, reject) => {

      this.ipfs.files.stat(this.baseFolder, { hash: true })
        .then((result: any) => {

          console.log(this.jsonArray);

          this.jsonArray.map((fileURL: string) => {
            return this.ipfsGateway + result.cid.toString() + fileURL;
          });

          console.log(this.jsonArray, this.metadata);

          console.log(`${this.jsonArray.length} == ${this.metadata.length}`);

          if (this.jsonArray.length == this.metadata.length)
            resolve("Success: JSON generated successfully.");
          else
            reject("Error: JSON lenght not equal to metadata lenght");
        })
        .catch((error: any) => {
          this.debugLog("Stat file error: ", error);
          reject("Error: base folder not found.");
        });
    })
  }

  public setBaseSVG(_path: string) {
    try {
      this.baseSVG = readFileSync(_path).toString();
      this.debugLog(this.baseSVG);
      return this.baseSVG;
    } catch (error) {
      this.debugLog(error);
      throw 'Could not find and SVG image at : ' + _path + '\nnote: make sure the path is relative to the root or absolute to the system.';
    }
  }

  public setConfigurations(_configs: any) {
    for (let config in _configs) {
      switch (config) {
        case "configPath":
          this.propertiesConfig = this.getConfigJson(_configs[config]);
          break;
        case "name":
          this.name = _configs[config];
          break;
        case "description":
          this.description = _configs[config];
          break;
        case "baseSVG":
          this.baseSVG = _configs[config];
          break;
        case "outPath":
          this.outPath = _configs[config];
          break;
        case "debug":
          this.debug = _configs[config];
          break;
        case "ipfsGateway":
          this.ipfsGateway = _configs[config];
          break;
        case "baseFolder":
          this.baseFolder = _configs[config];
          break;
        case "fileNamePrefix":
          this.fileNamePrefix = _configs[config];
          break;
        default:
          console.log(config + ": Cofignuation does not exist...");
      }
    }
  }

  public getJsonArray(): Array<string> {
    return this.jsonArray;
  }

  private getConfigJson(configPath: string) {
    try {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
    catch (error) {
      this.debugLog(error);

      let _config: any = {};

      for (let i = 1; i < 5; i++) {
        _config['property' + i] = [];
        for (let j = 1; j < 10; j++) {
          _config['property' + i].push({
            value: 'value' + j,
            weight: j * 10
          });
        }
      }

      this.propertiesConfig = _config;

      writeFileSync(configPath, JSON.stringify(this.propertiesConfig));

      throw 'No config file found... A new file was created at ./config.json';
    }
  }

  public async initIPFS() {
    if (!this.ipfs) {
      try {
        this.ipfs = await IPFS.create();

        await this.ipfs.files.rm(this.baseFolder, { recursive: true, flush: true }).catch((error: any) => this.debugLog(error));
        this.debugLog(this.ipfs);
      } catch (error) {
        this.debugLog(error);
        throw 'Error initializing IPFS instance.';
      }
    } else {
      console.log("IPFS instance already initialized");
    }
  }

  private camelCase(_string: string) {
    return _string.charAt(0).toLowerCase() + _string.slice(1).replace(" ", "");
  }

  private debugLog(...messages: any) {
    if (this.debug) console.log(...messages);
  }
}

export { AutoGen };