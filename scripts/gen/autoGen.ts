import { util } from "chai";
import { mkdirSync, readFileSync, rmdirSync, writeFileSync } from "fs";
import * as IPFS from "ipfs-core";
import random from "random";
var pathParse = require('path-parse');

class AutoGen {
  // Required Parameters
  private quantity: number;
  private ipfs: any;

  // Optional Parameters
  private propertiesConfig: any = this.getConfigJson("scripts/gen/config.json");
  private name: string = "SVG Logo";
  private description: string = "This logo has been autogenerated by Mochkai's script. If you would like to see it live chack it out on twitch!! https://www.twitch.tv/mochkai";
  private baseSVG: string = this.setBaseSVG('assets/baseSVG.svg');
  private outPath: string = 'assets/gen/';
  private ipfsGateway: string = 'https://ipfs.infura.io/ipfs/';
  private ipfsImagePath: string = 'mochkai-logo/images';
  private ipfsJsonPath: string = 'mochkai-logo/json';
  private svgPrefix: string = 'logo#';
  private debug: boolean = false;

  // Autogenerated Parameters
  private attributes: any = null;
  private metadata: any = null;

  constructor(_quantity: number, _configs?: any) {
    this.initIPFS();

    if (!_quantity && _quantity > 0) throw 'Quantity is required';

    this.quantity = _quantity;

    if (_configs)
      this.setConfigurations(_configs);

    if (!this.debug) process.stdout.write("Initialiing...");

    if (!this.propertiesConfig) throw 'No config file Found';

    rmdirSync(this.outPath, { recursive: true });

    if (!this.debug) process.stdout.write("Success!\n");
  }

  public generateMetadataAttributes() {
    let attributes = [];

    if (!this.debug) process.stdout.write("Generating Attributes... 0%");

    for (let item = 0; item < this.quantity; item++) {

      let _attributes = [];
      for (let property in this.propertiesConfig) {
        let curWeight = 0;
        let randomValue = random.float() * 100;
        let config = this.propertiesConfig[property];
        let configItem = config.find((p: any) => {
          curWeight += p.weight;

          if (curWeight - randomValue >= 0)
            return p;
        });

        _attributes.push({
          trait_type: property,
          value: configItem.value
        });
      }

      let tempAttr = JSON.stringify(_attributes);

      //Check for duplicate and restart process if found
      if (attributes.indexOf(tempAttr) == -1) {
        attributes[item] = tempAttr;
        if (!this.debug) {
          process.stdout.write("\r\x1b[K");
          process.stdout.write("Generating Attributes... " + ((attributes.length / this.quantity) * 100).toFixed(2) + "%");
        }
      } else {
        item--;
        this.debugLog("Duplicate Item found at ", attributes.indexOf(attributes[item]));
      }
    }

    if (!this.debug) process.stdout.write("\n");

    this.attributes = attributes;
  }

  public generateMetadata() {
    let metadata: any = [];

    if (!this.debug) process.stdout.write("Generating Metadata with SVGs... 0%");

    for (let item = 0; item < this.quantity; item++) {
      metadata[item] = {
        name: this.name + " #" + (item + 1),
        description: this.description,
        attributes: JSON.parse(this.attributes ? this.attributes[item] : false)
      };

      if (metadata[item].attributes)
        this.generateSVG(metadata[item].attributes, (item + 1));

      if (!this.debug) {
        process.stdout.write("\r\x1b[K");
        process.stdout.write("Generating Metadata with SVGs... " + ((metadata.length / this.quantity) * 100).toFixed(2) + "%");
      }
    }

    this.metadata = metadata;

    if (!this.debug) process.stdout.write("\n");

    this.debugLog(util.inspect(this.metadata, false, 10));
  }

  public setBaseSVG(_path: string) {
    try {
      this.baseSVG = readFileSync(_path).toString();
      this.debugLog(this.baseSVG);
      return this.baseSVG;
    } catch (error) {
      this.debugLog(error);
      throw 'Could not find and SVG image at : ' + _path + '\nnote: make sure the path is relative to the root or absolute to the system.';
    }
  }

  public setConfigurations(_configs: any) {

    for (let config in _configs) {
      switch (config) {
        case "configPath":
          this.propertiesConfig = this.getConfigJson(_configs[config]);
          break;
        case "name":
          this.name = _configs[config];
          break;
        case "description":
          this.description = _configs[config];
          break;
        case "baseSVG":
          this.baseSVG = _configs[config];
          break;
        case "outPath":
          this.outPath = _configs[config];
          break;
        case "debug":
          this.debug = _configs[config];
          break;
        case "ipfsGateway":
          this.ipfsGateway = _configs[config];
          break;
        case "ipfsImagePath":
          this.ipfsImagePath = _configs[config];
          break;
        case "ipfsJsonPath":
          this.ipfsJsonPath = _configs[config];
          break;
        case "svgPrefix":
          this.svgPrefix = _configs[config];
          break;
        default:
          console.log(config + ": Cofignuation does not exist...");
      }
    }


  }

  private getConfigJson(configPath: string) {
    try {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
    catch (error) {
      this.debugLog(error);

      let _config: any = {};

      for (let i = 1; i < 5; i++) {
        _config['property' + i] = [];
        for (let j = 1; j < 10; j++) {
          _config['property' + i].push({
            value: 'value' + j,
            weight: j * 10
          });
        }
      }

      this.propertiesConfig = _config;

      writeFileSync(configPath, JSON.stringify(this.propertiesConfig));

      throw 'No config file found... A new file was created at ./config.json';
    }
  }

  private async generateSVG(_attributes: any, index: number) {
    await this.initIPFS();

    const fileName = this.svgPrefix + index.toString().padStart(this.quantity.toString().length, "0") + ".svg";

    let genSVG = this.baseSVG;

    for (let attr in _attributes) {
      this.debugLog(attr, _attributes[attr]);
      let property = this.camelCase(_attributes[attr].trait_type);

      this.debugLog(property);

      genSVG = genSVG.replace("{{" + property + "}}", _attributes[attr].value);

    }

    this.debugLog(genSVG);

    try {
      mkdirSync(this.outPath, { recursive: true });
      if (! await this.ipfs.files.stat(this.ipfsImagePath, { hash: true }))
        await this.ipfs.files.mkdir(this.ipfsImagePath);


      writeFileSync(this.outPath + fileName, genSVG);
      console.log(await this.ipfs.files.write(this.ipfsImagePath + "/" + fileName, this.outPath + fileName));

    } catch (error) {
      this.debugLog(error);
      throw 'Error Generating the SVG';
    }
  }

  private async initIPFS() {
    if (!this.ipfs)
      this.ipfs = await IPFS.create();
  }

  private camelCase(_string: string) {
    return _string.charAt(0).toLowerCase() + _string.slice(1).replace(" ", "");
  }

  private debugLog(...messages: any) {
    if (this.debug) console.log(...messages);
  }
}

export { AutoGen };