import { rejects } from "assert";
import { util } from "chai";
import { mkdirSync, readFileSync, rmdirSync, writeFileSync } from "fs";
import * as IPFS from "ipfs-http-client";
import random from "random";

class AutoGen {
  // Required Parameters
  private quantity: number;
  private ipfs: any;

  // Optional Parameters
  private propertiesConfig: any = this.getConfigJson("scripts/gen/config.json");
  private name: string = "My Project Name";
  private description: string = "My Project Description";
  private baseSVG: string = this.setBaseSVG('assets/baseSVG.svg');
  private outPath: string = 'assets/gen';
  private ipfsGateway: string = 'https://infura-ipfs.io/ipfs/';
  private baseFolder: string = '/myBaseFolder/';
  private fileNamePrefix: string = 'myFilePrefix_';
  private debug: boolean = false;
  private logs: boolean = true;

  // Autogenerated Parameters
  private metadata: Array<any> = [];
  private svgObjects: Array<any> = [];
  private jsonObjects: Array<any> = [];

  constructor(_quantity: number, _configs?: any) {
    if (!_quantity && _quantity > 0) throw 'Quantity is required';

    this.quantity = _quantity;

    if (_configs)
      this.setConfigurations(_configs);

    this.log("Initializing... ");

    if (!this.propertiesConfig) throw 'No config file Found';

    rmdirSync(this.outPath + this.baseFolder, { recursive: true });

    this.log("Success!\n");
  }

  public generateMetadata() {
    for (let item = 0; item < this.quantity; item++) {

      let attributesTracker: any = [];
      let attributesData: any = [];

      for (let property in this.propertiesConfig) {
        let curWeight = 0;
        let randomValue = random.float() * 100;
        let config = this.propertiesConfig[property];
        let configItem = config.find((p: any) => {
          curWeight += p.weight;

          if (curWeight - randomValue >= 0)
            return p;
        });

        attributesData.push({
          trait_type: property,
          value: configItem.value.toString()
        });
      }

      let attributeString = JSON.stringify(attributesData);

      //Check for duplicate and restart process if found
      if (attributesTracker.indexOf(attributeString) == -1) {
        attributesTracker[item] = attributeString;
        this.metadata[item] = {
          name: this.name + " #" + (item + 1),
          description: this.description,
          attributes: attributesData
        };
        this.progressLog("Generating Metadata... " + ((this.metadata.length / this.quantity) * 100).toFixed(2) + "%");
      } else {
        this.debugLog("Duplicate Item found at ", item);
        item--;
      }
    }

    this.storeMetadata();

    this.log("\n");

    this.debugLog(util.inspect(this.metadata, false, 10));
  }

  private storeMetadata() {
    const fullPath = this.outPath + this.baseFolder + "metadata";
    const metadataString = JSON.stringify(this.metadata);

    try {
      mkdirSync(fullPath, { recursive: true });
      writeFileSync(fullPath + "/metadata.json", metadataString);
      this.debugLog("File generated successfully : ", fullPath + "/metadata.json");
    } catch (error) {
      this.debugLog("Error saving file to disk : ", fullPath + "/metadata.json");
      this.debugLog(error);
      throw 'Error Generating the Metadata';
    }
  }

  public generateSVG() {

    for (let index in this.metadata) {
      const fileNumber = Number(index) + 1;

      this.progressLog("Generating SVG... " + ((fileNumber / this.quantity) * 100).toFixed(2) + "%");

      const fileName = "/" + this.fileNamePrefix + fileNumber.toString().padStart(this.quantity.toString().length, "0") + ".svg";
      let genSVG = this.baseSVG;

      this.debugLog(index, this.metadata[index]);

      let _attributes = this.metadata[index].attributes;

      for (let attr in _attributes) {
        let property = this.camelCase(_attributes[attr].trait_type);

        this.debugLog(property);

        genSVG = genSVG.replace("{{" + property + "}}", _attributes[attr].value);
      }

      this.debugLog(genSVG);

      const fullPath = this.outPath + this.baseFolder + "image";

      try {
        mkdirSync(fullPath, { recursive: true });
        writeFileSync(fullPath + fileName, genSVG);
        this.debugLog("File generated successfully : ", fullPath + fileName);
      } catch (error) {
        this.debugLog("Error saving file to disk : ", fullPath + fileName);
        this.debugLog(error);
        throw 'Error Generating the SVG';
      }

      this.svgObjects[index] = { path: fileName, content: genSVG };
    }

    this.log("\n")
  }

  public async sendSVGFilesToIPFS() {

    let index = 0;

    for await (const result of this.ipfs.addAll(this.svgObjects, { pin: true, wrapWithDirectory: true })) {
      if (result.path != '') {
        this.metadata[index].image = result.path;
        index++;
        this.progressLog("Sending SVG Files to IPFS... " + ((index / this.quantity) * 100).toFixed(2) + "%");
      } else {

        this.log("\n");
        await this.ipfs.files.cp(result.cid, `/${this.baseFolder}/images`, { parents: true, flush: true }).catch((err: any) => this.debugLog(err));

        this.mapFileURLToMetadata(result.cid.toString());
      }
    }
  }

  private mapFileURLToMetadata(hash: string) {

    this.metadata.map((item: any) => {
      this.progressLog(`Mapping file to IPFS: ${item.name}`);
      item.image = this.ipfsGateway + hash + "/" + item.image;
      return item;
    });

    this.log("\n");

    this.storeMetadata();
  }

  public generateJsonFiles() {
    this.debugLog("About to generate JSON Files...");

    const fullPath = this.outPath + this.baseFolder + "json";

    for (let item in this.metadata) {
      const fileNumber = Number(item) + 1;
      const fileName = "/" + this.fileNamePrefix + fileNumber.toString().padStart(this.quantity.toString().length, "0") + ".json";
      const jsonMetadata = JSON.stringify(this.metadata[item]);

      try {
        mkdirSync(fullPath, { recursive: true });
        writeFileSync(fullPath + fileName, jsonMetadata);
        this.debugLog("File generated successfully : ", fullPath + fileName);
      } catch (error) {
        this.debugLog("Error saving file to disk : ", fullPath + fileName);
        this.debugLog(error);
        throw 'Error Generating the SVG';
      }

      this.jsonObjects[item] = { path: fileName, content: jsonMetadata };
    }
  }

  public async sendJSONFilesToIPFS(): Promise<string> {
    let index = 0;

    return new Promise(async (resolve, reject) => {
      for await (const result of this.ipfs.addAll(this.jsonObjects, { pin: true, wrapWithDirectory: true })) {
        if (result.path == '') {
          await this.ipfs.files.cp(result.cid, `/${this.baseFolder}/json`, { parents: true, flush: true }).catch((err: any) => {
            this.debugLog(err);
            reject(`Error: Could not copy folder to: /${this.baseFolder}/json`);
          });

          resolve(result.cid.toString());
          this.log("\n");
        }
        else {
          index++;
          this.progressLog("Sending JSON Files to IPFS... " + ((index / this.quantity) * 100).toFixed(2) + "%");
        }
      }
    });

  }

  public setBaseSVG(_path: string) {
    try {
      this.baseSVG = readFileSync(_path).toString();
      this.debugLog(this.baseSVG);
      return this.baseSVG;
    } catch (error) {
      this.debugLog(error);
      throw 'Could not find and SVG image at : ' + _path + '\nnote: make sure the path is relative to the root or absolute to the system.';
    }
  }

  public setConfigurations(_configs: any) {
    for (let config in _configs) {
      switch (config) {
        case "configPath":
          this.propertiesConfig = this.getConfigJson(_configs[config]);
          break;
        case "name":
          this.name = _configs[config];
          break;
        case "description":
          this.description = _configs[config];
          break;
        case "baseSVG":
          this.baseSVG = this.setBaseSVG(_configs[config]);
          break;
        case "outPath":
          this.outPath = _configs[config];
          break;
        case "debug":
          this.debug = _configs[config];
          break;
        case "logs":
          this.logs = _configs[config];
          break;
        case "ipfsGateway":
          this.ipfsGateway = _configs[config];
          break;
        case "baseFolder":
          this.baseFolder = _configs[config];
          break;
        case "fileNamePrefix":
          this.fileNamePrefix = _configs[config];
          break;
        default:
          console.log(config + ": Cofignuation does not exist...");
      }
    }
  }

  public getFilePrefix() {
    return this.fileNamePrefix;
  }

  private getConfigJson(configPath: string) {
    try {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
    catch (error) {
      this.debugLog(error);

      let _config: any = {};

      for (let i = 1; i < 5; i++) {
        _config['property' + i] = [];
        for (let j = 1; j < 10; j++) {
          _config['property' + i].push({
            value: 'value' + j,
            weight: j * 10
          });
        }
      }

      this.propertiesConfig = _config;

      writeFileSync(configPath, JSON.stringify(this.propertiesConfig));

      throw 'No config file found... A new file was created at ./config.json';
    }
  }

  public async initIPFS() {
    if (!this.ipfs) {
      try {
        this.ipfs = await IPFS.create();

        await this.ipfs.files.rm(this.baseFolder, { recursive: true, flush: true }).catch((error: any) => this.debugLog(error));
        this.debugLog(this.ipfs);
      } catch (error) {
        this.debugLog(error);
        throw 'Error initializing IPFS instance.';
      }
    } else {
      console.log("IPFS instance already initialized");
    }
  }

  private camelCase(_string: string) {
    return _string.charAt(0).toLowerCase() + _string.slice(1).replace(" ", "");
  }

  private debugLog(...messages: any) {
    if (this.debug) console.log(...messages);
  }

  private log(message: string) {
    if (this.logs) process.stdout.write(message);
  }

  private progressLog(message: string) {
    if (!this.debug && this.logs) process.stdout.write("\r\x1b[K");
    this.log(message);
  }
}

export { AutoGen };