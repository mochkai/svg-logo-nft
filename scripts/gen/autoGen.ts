import { util } from "chai";
import { mkdirSync, readFileSync, rmdirSync, writeFileSync } from "fs";
import * as IPFS from "ipfs-http-client";
import random from "random";
var pathParse = require('path-parse');

class AutoGen {
  // Required Parameters
  private quantity: number;
  private ipfs: any;

  // Optional Parameters
  private propertiesConfig: any = this.getConfigJson("scripts/gen/config.json");
  private name: string = "SVG Logo";
  private description: string = "This logo has been autogenerated by Mochkai's script. If you would like to see it live chack it out on twitch!! https://www.twitch.tv/mochkai";
  private baseSVG: string = this.setBaseSVG('assets/baseSVG.svg');
  private outPath: string = 'assets/gen';
  private ipfsGateway: string = 'https://ipfs.infura.io/ipfs/';
  private imagePath: string = '/mochkai-logo/images';
  private jsonPath: string = '/mochkai-logo/json';
  private svgPrefix: string = 'logo#';
  private debug: boolean = true;

  // Autogenerated Parameters
  private attributes: any = null;
  private metadata: any = null;

  constructor(_quantity: number, _configs?: any) {
    if (!_quantity && _quantity > 0) throw 'Quantity is required';

    this.quantity = _quantity;

    if (_configs)
      this.setConfigurations(_configs);

    if (!this.debug) process.stdout.write("Initialiing...");

    if (!this.propertiesConfig) throw 'No config file Found';

    rmdirSync(this.outPath, { recursive: true });

    if (!this.debug) process.stdout.write("Success!\n");
  }

  public generateMetadataAttributes() {
    let attributes = [];

    if (!this.debug) process.stdout.write("Generating Attributes... 0%");

    for (let item = 0; item < this.quantity; item++) {

      let _attributes = [];
      for (let property in this.propertiesConfig) {
        let curWeight = 0;
        let randomValue = random.float() * 100;
        let config = this.propertiesConfig[property];
        let configItem = config.find((p: any) => {
          curWeight += p.weight;

          if (curWeight - randomValue >= 0)
            return p;
        });

        _attributes.push({
          trait_type: property,
          value: configItem.value
        });
      }

      let tempAttr = JSON.stringify(_attributes);

      //Check for duplicate and restart process if found
      if (attributes.indexOf(tempAttr) == -1) {
        attributes[item] = tempAttr;
        if (!this.debug) {
          process.stdout.write("\r\x1b[K");
          process.stdout.write("Generating Attributes... " + ((attributes.length / this.quantity) * 100).toFixed(2) + "%");
        }
      } else {
        item--;
        this.debugLog("Duplicate Item found at ", attributes.indexOf(attributes[item]));
      }
    }

    if (!this.debug) process.stdout.write("\n");

    this.attributes = attributes;
  }

  public async generateMetadata() {
    let metadata: any = [];

    if (!this.debug) process.stdout.write("Generating Metadata with SVGs... 0%");

    for (let item = 0; item < this.quantity; item++) {
      metadata[item] = {
        name: this.name + " #" + (item + 1),
        description: this.description,
        attributes: JSON.parse(this.attributes ? this.attributes[item] : false)
      };

      if (metadata[item].attributes)
        await this.generateSVG(metadata[item].attributes, (item + 1));

      if (!this.debug) {
        process.stdout.write("\r\x1b[K");
        process.stdout.write("Generating Metadata with SVGs... " + ((metadata.length / this.quantity) * 100).toFixed(2) + "%");
      }
    }

    this.ipfs.files.stat(this.imagePath, { hash: true })
      .then((result: any) => console.log(result))
      .catch((error: any) => this.debugLog("Stat file error: ", error))

    this.metadata = metadata;

    if (!this.debug) process.stdout.write("\n");

    this.debugLog(util.inspect(this.metadata, false, 10));
  }

  public setBaseSVG(_path: string) {
    try {
      this.baseSVG = readFileSync(_path).toString();
      this.debugLog(this.baseSVG);
      return this.baseSVG;
    } catch (error) {
      this.debugLog(error);
      throw 'Could not find and SVG image at : ' + _path + '\nnote: make sure the path is relative to the root or absolute to the system.';
    }
  }

  public setConfigurations(_configs: any) {

    for (let config in _configs) {
      switch (config) {
        case "configPath":
          this.propertiesConfig = this.getConfigJson(_configs[config]);
          break;
        case "name":
          this.name = _configs[config];
          break;
        case "description":
          this.description = _configs[config];
          break;
        case "baseSVG":
          this.baseSVG = _configs[config];
          break;
        case "outPath":
          this.outPath = _configs[config];
          break;
        case "debug":
          this.debug = _configs[config];
          break;
        case "ipfsGateway":
          this.ipfsGateway = _configs[config];
          break;
        case "imagePath":
          this.imagePath = _configs[config];
          break;
        case "jsonPath":
          this.jsonPath = _configs[config];
          break;
        case "svgPrefix":
          this.svgPrefix = _configs[config];
          break;
        default:
          console.log(config + ": Cofignuation does not exist...");
      }
    }
  }

  private getConfigJson(configPath: string) {
    try {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
    catch (error) {
      this.debugLog(error);

      let _config: any = {};

      for (let i = 1; i < 5; i++) {
        _config['property' + i] = [];
        for (let j = 1; j < 10; j++) {
          _config['property' + i].push({
            value: 'value' + j,
            weight: j * 10
          });
        }
      }

      this.propertiesConfig = _config;

      writeFileSync(configPath, JSON.stringify(this.propertiesConfig));

      throw 'No config file found... A new file was created at ./config.json';
    }
  }

  private async generateSVG(_attributes: any, index: number) {
    const fileName = "/" + this.svgPrefix + index.toString().padStart(this.quantity.toString().length, "0") + ".svg";

    let genSVG = this.baseSVG;

    for (let attr in _attributes) {
      this.debugLog(attr, _attributes[attr]);
      let property = this.camelCase(_attributes[attr].trait_type);

      this.debugLog(property);

      genSVG = genSVG.replace("{{" + property + "}}", _attributes[attr].value);

    }

    this.debugLog(genSVG);

    let fullPath = this.outPath + this.imagePath;

    try {
      mkdirSync(fullPath, { recursive: true });
      writeFileSync(fullPath + fileName, genSVG);
      this.debugLog("File generated successfully : ", fullPath + fileName);
    } catch (error) {
      this.debugLog("Error saving file to disk : ", fullPath + fileName);
      this.debugLog(error);
      throw 'Error Generating the SVG';
    }

    this.ipfs.add({ path: fileName, content: genSVG }, { pin: true })
      .then((result: any) => {
        this.debugLog("File added to IPFS: ", result);

        this.debugLog("About to copy file to: ", this.imagePath + fileName);
        this.ipfs.files.cp(result.cid, this.imagePath + fileName, { parents: true, flush: true })
          .catch((error: any) => console.log(error));
      })
      .catch((error: any) => console.log(error));
  }

  public async initIPFS() {
    if (!this.ipfs) {
      try {
        this.ipfs = await IPFS.create();

        await this.ipfs.files.rm(this.imagePath, { recursive: true, flush: true }).catch((error: any) => this.debugLog(error));
        await this.ipfs.files.rm(this.jsonPath, { recursive: true, flush: true }).catch((error: any) => this.debugLog(error));
        this.debugLog(this.ipfs);
      } catch (error) {
        this.debugLog(error);
        throw 'Error initializing IPFS instance.';
      }
    } else {
      console.log("IPFS instance already initialized");
    }
  }

  private camelCase(_string: string) {
    return _string.charAt(0).toLowerCase() + _string.slice(1).replace(" ", "");
  }

  private debugLog(...messages: any) {
    if (this.debug) console.log(...messages);
  }
}

export { AutoGen };